package wallet

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	mm_models "github.com/Nizom98/wallet/internal/models"
	"github.com/gojuno/minimock/v3"
)

// RepositoryMock implements models.WalletRepository
type RepositoryMock struct {
	t minimock.Tester

	funcAll          func() (wa1 []mm_models.Walleter)
	inspectFuncAll   func()
	afterAllCounter  uint64
	beforeAllCounter uint64
	AllMock          mRepositoryMockAll

	funcByID          func(id string) (w1 mm_models.Walleter, err error)
	inspectFuncByID   func(id string)
	afterByIDCounter  uint64
	beforeByIDCounter uint64
	ByIDMock          mRepositoryMockByID

	funcCreate          func(name string, balance float64, status bool) (w1 mm_models.Walleter)
	inspectFuncCreate   func(name string, balance float64, status bool)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mRepositoryMockCreate

	funcTransaction          func(fn func(repo mm_models.WalletRepository) error) (err error)
	inspectFuncTransaction   func(fn func(repo mm_models.WalletRepository) error)
	afterTransactionCounter  uint64
	beforeTransactionCounter uint64
	TransactionMock          mRepositoryMockTransaction

	funcUpdateByID          func(id string, name *string, balance *float64, status *bool) (err error)
	inspectFuncUpdateByID   func(id string, name *string, balance *float64, status *bool)
	afterUpdateByIDCounter  uint64
	beforeUpdateByIDCounter uint64
	UpdateByIDMock          mRepositoryMockUpdateByID
}

// NewRepositoryMock returns a mock for models.WalletRepository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AllMock = mRepositoryMockAll{mock: m}

	m.ByIDMock = mRepositoryMockByID{mock: m}
	m.ByIDMock.callArgs = []*RepositoryMockByIDParams{}

	m.CreateMock = mRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*RepositoryMockCreateParams{}

	m.TransactionMock = mRepositoryMockTransaction{mock: m}
	m.TransactionMock.callArgs = []*RepositoryMockTransactionParams{}

	m.UpdateByIDMock = mRepositoryMockUpdateByID{mock: m}
	m.UpdateByIDMock.callArgs = []*RepositoryMockUpdateByIDParams{}

	return m
}

type mRepositoryMockAll struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockAllExpectation
	expectations       []*RepositoryMockAllExpectation
}

// RepositoryMockAllExpectation specifies expectation struct of the WalletRepository.All
type RepositoryMockAllExpectation struct {
	mock *RepositoryMock

	results *RepositoryMockAllResults
	Counter uint64
}

// RepositoryMockAllResults contains results of the WalletRepository.All
type RepositoryMockAllResults struct {
	wa1 []mm_models.Walleter
}

// Expect sets up expected params for WalletRepository.All
func (mmAll *mRepositoryMockAll) Expect() *mRepositoryMockAll {
	if mmAll.mock.funcAll != nil {
		mmAll.mock.t.Fatalf("RepositoryMock.All mock is already set by Set")
	}

	if mmAll.defaultExpectation == nil {
		mmAll.defaultExpectation = &RepositoryMockAllExpectation{}
	}

	return mmAll
}

// Inspect accepts an inspector function that has same arguments as the WalletRepository.All
func (mmAll *mRepositoryMockAll) Inspect(f func()) *mRepositoryMockAll {
	if mmAll.mock.inspectFuncAll != nil {
		mmAll.mock.t.Fatalf("Inspect function is already set for RepositoryMock.All")
	}

	mmAll.mock.inspectFuncAll = f

	return mmAll
}

// Return sets up results that will be returned by WalletRepository.All
func (mmAll *mRepositoryMockAll) Return(wa1 []mm_models.Walleter) *RepositoryMock {
	if mmAll.mock.funcAll != nil {
		mmAll.mock.t.Fatalf("RepositoryMock.All mock is already set by Set")
	}

	if mmAll.defaultExpectation == nil {
		mmAll.defaultExpectation = &RepositoryMockAllExpectation{mock: mmAll.mock}
	}
	mmAll.defaultExpectation.results = &RepositoryMockAllResults{wa1}
	return mmAll.mock
}

// Set uses given function f to mock the WalletRepository.All method
func (mmAll *mRepositoryMockAll) Set(f func() (wa1 []mm_models.Walleter)) *RepositoryMock {
	if mmAll.defaultExpectation != nil {
		mmAll.mock.t.Fatalf("Default expectation is already set for the WalletRepository.All method")
	}

	if len(mmAll.expectations) > 0 {
		mmAll.mock.t.Fatalf("Some expectations are already set for the WalletRepository.All method")
	}

	mmAll.mock.funcAll = f
	return mmAll.mock
}

// All implements models.WalletRepository
func (mmAll *RepositoryMock) All() (wa1 []mm_models.Walleter) {
	mm_atomic.AddUint64(&mmAll.beforeAllCounter, 1)
	defer mm_atomic.AddUint64(&mmAll.afterAllCounter, 1)

	if mmAll.inspectFuncAll != nil {
		mmAll.inspectFuncAll()
	}

	if mmAll.AllMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAll.AllMock.defaultExpectation.Counter, 1)

		mm_results := mmAll.AllMock.defaultExpectation.results
		if mm_results == nil {
			mmAll.t.Fatal("No results are set for the RepositoryMock.All")
		}
		return (*mm_results).wa1
	}
	if mmAll.funcAll != nil {
		return mmAll.funcAll()
	}
	mmAll.t.Fatalf("Unexpected call to RepositoryMock.All.")
	return
}

// AllAfterCounter returns a count of finished RepositoryMock.All invocations
func (mmAll *RepositoryMock) AllAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAll.afterAllCounter)
}

// AllBeforeCounter returns a count of RepositoryMock.All invocations
func (mmAll *RepositoryMock) AllBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAll.beforeAllCounter)
}

// MinimockAllDone returns true if the count of the All invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockAllDone() bool {
	for _, e := range m.AllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAllCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAll != nil && mm_atomic.LoadUint64(&m.afterAllCounter) < 1 {
		return false
	}
	return true
}

// MinimockAllInspect logs each unmet expectation
func (m *RepositoryMock) MinimockAllInspect() {
	for _, e := range m.AllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RepositoryMock.All")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAllCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.All")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAll != nil && mm_atomic.LoadUint64(&m.afterAllCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.All")
	}
}

type mRepositoryMockByID struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockByIDExpectation
	expectations       []*RepositoryMockByIDExpectation

	callArgs []*RepositoryMockByIDParams
	mutex    sync.RWMutex
}

// RepositoryMockByIDExpectation specifies expectation struct of the WalletRepository.ByID
type RepositoryMockByIDExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockByIDParams
	results *RepositoryMockByIDResults
	Counter uint64
}

// RepositoryMockByIDParams contains parameters of the WalletRepository.ByID
type RepositoryMockByIDParams struct {
	id string
}

// RepositoryMockByIDResults contains results of the WalletRepository.ByID
type RepositoryMockByIDResults struct {
	w1  mm_models.Walleter
	err error
}

// Expect sets up expected params for WalletRepository.ByID
func (mmByID *mRepositoryMockByID) Expect(id string) *mRepositoryMockByID {
	if mmByID.mock.funcByID != nil {
		mmByID.mock.t.Fatalf("RepositoryMock.ByID mock is already set by Set")
	}

	if mmByID.defaultExpectation == nil {
		mmByID.defaultExpectation = &RepositoryMockByIDExpectation{}
	}

	mmByID.defaultExpectation.params = &RepositoryMockByIDParams{id}
	for _, e := range mmByID.expectations {
		if minimock.Equal(e.params, mmByID.defaultExpectation.params) {
			mmByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmByID.defaultExpectation.params)
		}
	}

	return mmByID
}

// Inspect accepts an inspector function that has same arguments as the WalletRepository.ByID
func (mmByID *mRepositoryMockByID) Inspect(f func(id string)) *mRepositoryMockByID {
	if mmByID.mock.inspectFuncByID != nil {
		mmByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ByID")
	}

	mmByID.mock.inspectFuncByID = f

	return mmByID
}

// Return sets up results that will be returned by WalletRepository.ByID
func (mmByID *mRepositoryMockByID) Return(w1 mm_models.Walleter, err error) *RepositoryMock {
	if mmByID.mock.funcByID != nil {
		mmByID.mock.t.Fatalf("RepositoryMock.ByID mock is already set by Set")
	}

	if mmByID.defaultExpectation == nil {
		mmByID.defaultExpectation = &RepositoryMockByIDExpectation{mock: mmByID.mock}
	}
	mmByID.defaultExpectation.results = &RepositoryMockByIDResults{w1, err}
	return mmByID.mock
}

// Set uses given function f to mock the WalletRepository.ByID method
func (mmByID *mRepositoryMockByID) Set(f func(id string) (w1 mm_models.Walleter, err error)) *RepositoryMock {
	if mmByID.defaultExpectation != nil {
		mmByID.mock.t.Fatalf("Default expectation is already set for the WalletRepository.ByID method")
	}

	if len(mmByID.expectations) > 0 {
		mmByID.mock.t.Fatalf("Some expectations are already set for the WalletRepository.ByID method")
	}

	mmByID.mock.funcByID = f
	return mmByID.mock
}

// When sets expectation for the WalletRepository.ByID which will trigger the result defined by the following
// Then helper
func (mmByID *mRepositoryMockByID) When(id string) *RepositoryMockByIDExpectation {
	if mmByID.mock.funcByID != nil {
		mmByID.mock.t.Fatalf("RepositoryMock.ByID mock is already set by Set")
	}

	expectation := &RepositoryMockByIDExpectation{
		mock:   mmByID.mock,
		params: &RepositoryMockByIDParams{id},
	}
	mmByID.expectations = append(mmByID.expectations, expectation)
	return expectation
}

// Then sets up WalletRepository.ByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockByIDExpectation) Then(w1 mm_models.Walleter, err error) *RepositoryMock {
	e.results = &RepositoryMockByIDResults{w1, err}
	return e.mock
}

// ByID implements models.WalletRepository
func (mmByID *RepositoryMock) ByID(id string) (w1 mm_models.Walleter, err error) {
	mm_atomic.AddUint64(&mmByID.beforeByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmByID.afterByIDCounter, 1)

	if mmByID.inspectFuncByID != nil {
		mmByID.inspectFuncByID(id)
	}

	mm_params := &RepositoryMockByIDParams{id}

	// Record call args
	mmByID.ByIDMock.mutex.Lock()
	mmByID.ByIDMock.callArgs = append(mmByID.ByIDMock.callArgs, mm_params)
	mmByID.ByIDMock.mutex.Unlock()

	for _, e := range mmByID.ByIDMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.w1, e.results.err
		}
	}

	if mmByID.ByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmByID.ByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmByID.ByIDMock.defaultExpectation.params
		mm_got := RepositoryMockByIDParams{id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmByID.t.Errorf("RepositoryMock.ByID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmByID.ByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmByID.t.Fatal("No results are set for the RepositoryMock.ByID")
		}
		return (*mm_results).w1, (*mm_results).err
	}
	if mmByID.funcByID != nil {
		return mmByID.funcByID(id)
	}
	mmByID.t.Fatalf("Unexpected call to RepositoryMock.ByID. %v", id)
	return
}

// ByIDAfterCounter returns a count of finished RepositoryMock.ByID invocations
func (mmByID *RepositoryMock) ByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmByID.afterByIDCounter)
}

// ByIDBeforeCounter returns a count of RepositoryMock.ByID invocations
func (mmByID *RepositoryMock) ByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmByID.beforeByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmByID *mRepositoryMockByID) Calls() []*RepositoryMockByIDParams {
	mmByID.mutex.RLock()

	argCopy := make([]*RepositoryMockByIDParams, len(mmByID.callArgs))
	copy(argCopy, mmByID.callArgs)

	mmByID.mutex.RUnlock()

	return argCopy
}

// MinimockByIDDone returns true if the count of the ByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockByIDDone() bool {
	for _, e := range m.ByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterByIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcByID != nil && mm_atomic.LoadUint64(&m.afterByIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockByIDInspect() {
	for _, e := range m.ByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ByID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterByIDCounter) < 1 {
		if m.ByIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.ByID")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ByID with params: %#v", *m.ByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcByID != nil && mm_atomic.LoadUint64(&m.afterByIDCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.ByID")
	}
}

type mRepositoryMockCreate struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateExpectation
	expectations       []*RepositoryMockCreateExpectation

	callArgs []*RepositoryMockCreateParams
	mutex    sync.RWMutex
}

// RepositoryMockCreateExpectation specifies expectation struct of the WalletRepository.Create
type RepositoryMockCreateExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockCreateParams
	results *RepositoryMockCreateResults
	Counter uint64
}

// RepositoryMockCreateParams contains parameters of the WalletRepository.Create
type RepositoryMockCreateParams struct {
	name    string
	balance float64
	status  bool
}

// RepositoryMockCreateResults contains results of the WalletRepository.Create
type RepositoryMockCreateResults struct {
	w1 mm_models.Walleter
}

// Expect sets up expected params for WalletRepository.Create
func (mmCreate *mRepositoryMockCreate) Expect(name string, balance float64, status bool) *mRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("RepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &RepositoryMockCreateExpectation{}
	}

	mmCreate.defaultExpectation.params = &RepositoryMockCreateParams{name, balance, status}
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the WalletRepository.Create
func (mmCreate *mRepositoryMockCreate) Inspect(f func(name string, balance float64, status bool)) *mRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for RepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by WalletRepository.Create
func (mmCreate *mRepositoryMockCreate) Return(w1 mm_models.Walleter) *RepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("RepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &RepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &RepositoryMockCreateResults{w1}
	return mmCreate.mock
}

// Set uses given function f to mock the WalletRepository.Create method
func (mmCreate *mRepositoryMockCreate) Set(f func(name string, balance float64, status bool) (w1 mm_models.Walleter)) *RepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the WalletRepository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the WalletRepository.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// When sets expectation for the WalletRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mRepositoryMockCreate) When(name string, balance float64, status bool) *RepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("RepositoryMock.Create mock is already set by Set")
	}

	expectation := &RepositoryMockCreateExpectation{
		mock:   mmCreate.mock,
		params: &RepositoryMockCreateParams{name, balance, status},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up WalletRepository.Create return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateExpectation) Then(w1 mm_models.Walleter) *RepositoryMock {
	e.results = &RepositoryMockCreateResults{w1}
	return e.mock
}

// Create implements models.WalletRepository
func (mmCreate *RepositoryMock) Create(name string, balance float64, status bool) (w1 mm_models.Walleter) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(name, balance, status)
	}

	mm_params := &RepositoryMockCreateParams{name, balance, status}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.w1
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_got := RepositoryMockCreateParams{name, balance, status}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("RepositoryMock.Create got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the RepositoryMock.Create")
		}
		return (*mm_results).w1
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(name, balance, status)
	}
	mmCreate.t.Fatalf("Unexpected call to RepositoryMock.Create. %v %v %v", name, balance, status)
	return
}

// CreateAfterCounter returns a count of finished RepositoryMock.Create invocations
func (mmCreate *RepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of RepositoryMock.Create invocations
func (mmCreate *RepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mRepositoryMockCreate) Calls() []*RepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateDone() bool {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.Create with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.Create")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.Create with params: %#v", *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.Create")
	}
}

type mRepositoryMockTransaction struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockTransactionExpectation
	expectations       []*RepositoryMockTransactionExpectation

	callArgs []*RepositoryMockTransactionParams
	mutex    sync.RWMutex
}

// RepositoryMockTransactionExpectation specifies expectation struct of the WalletRepository.Transaction
type RepositoryMockTransactionExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockTransactionParams
	results *RepositoryMockTransactionResults
	Counter uint64
}

// RepositoryMockTransactionParams contains parameters of the WalletRepository.Transaction
type RepositoryMockTransactionParams struct {
	fn func(repo mm_models.WalletRepository) error
}

// RepositoryMockTransactionResults contains results of the WalletRepository.Transaction
type RepositoryMockTransactionResults struct {
	err error
}

// Expect sets up expected params for WalletRepository.Transaction
func (mmTransaction *mRepositoryMockTransaction) Expect(fn func(repo mm_models.WalletRepository) error) *mRepositoryMockTransaction {
	if mmTransaction.mock.funcTransaction != nil {
		mmTransaction.mock.t.Fatalf("RepositoryMock.Transaction mock is already set by Set")
	}

	if mmTransaction.defaultExpectation == nil {
		mmTransaction.defaultExpectation = &RepositoryMockTransactionExpectation{}
	}

	mmTransaction.defaultExpectation.params = &RepositoryMockTransactionParams{fn}
	for _, e := range mmTransaction.expectations {
		if minimock.Equal(e.params, mmTransaction.defaultExpectation.params) {
			mmTransaction.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTransaction.defaultExpectation.params)
		}
	}

	return mmTransaction
}

// Inspect accepts an inspector function that has same arguments as the WalletRepository.Transaction
func (mmTransaction *mRepositoryMockTransaction) Inspect(f func(fn func(repo mm_models.WalletRepository) error)) *mRepositoryMockTransaction {
	if mmTransaction.mock.inspectFuncTransaction != nil {
		mmTransaction.mock.t.Fatalf("Inspect function is already set for RepositoryMock.Transaction")
	}

	mmTransaction.mock.inspectFuncTransaction = f

	return mmTransaction
}

// Return sets up results that will be returned by WalletRepository.Transaction
func (mmTransaction *mRepositoryMockTransaction) Return(err error) *RepositoryMock {
	if mmTransaction.mock.funcTransaction != nil {
		mmTransaction.mock.t.Fatalf("RepositoryMock.Transaction mock is already set by Set")
	}

	if mmTransaction.defaultExpectation == nil {
		mmTransaction.defaultExpectation = &RepositoryMockTransactionExpectation{mock: mmTransaction.mock}
	}
	mmTransaction.defaultExpectation.results = &RepositoryMockTransactionResults{err}
	return mmTransaction.mock
}

// Set uses given function f to mock the WalletRepository.Transaction method
func (mmTransaction *mRepositoryMockTransaction) Set(f func(fn func(repo mm_models.WalletRepository) error) (err error)) *RepositoryMock {
	if mmTransaction.defaultExpectation != nil {
		mmTransaction.mock.t.Fatalf("Default expectation is already set for the WalletRepository.Transaction method")
	}

	if len(mmTransaction.expectations) > 0 {
		mmTransaction.mock.t.Fatalf("Some expectations are already set for the WalletRepository.Transaction method")
	}

	mmTransaction.mock.funcTransaction = f
	return mmTransaction.mock
}

// When sets expectation for the WalletRepository.Transaction which will trigger the result defined by the following
// Then helper
func (mmTransaction *mRepositoryMockTransaction) When(fn func(repo mm_models.WalletRepository) error) *RepositoryMockTransactionExpectation {
	if mmTransaction.mock.funcTransaction != nil {
		mmTransaction.mock.t.Fatalf("RepositoryMock.Transaction mock is already set by Set")
	}

	expectation := &RepositoryMockTransactionExpectation{
		mock:   mmTransaction.mock,
		params: &RepositoryMockTransactionParams{fn},
	}
	mmTransaction.expectations = append(mmTransaction.expectations, expectation)
	return expectation
}

// Then sets up WalletRepository.Transaction return parameters for the expectation previously defined by the When method
func (e *RepositoryMockTransactionExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockTransactionResults{err}
	return e.mock
}

// Transaction implements models.WalletRepository
func (mmTransaction *RepositoryMock) Transaction(fn func(repo mm_models.WalletRepository) error) (err error) {
	mm_atomic.AddUint64(&mmTransaction.beforeTransactionCounter, 1)
	defer mm_atomic.AddUint64(&mmTransaction.afterTransactionCounter, 1)

	if mmTransaction.inspectFuncTransaction != nil {
		mmTransaction.inspectFuncTransaction(fn)
	}

	mm_params := &RepositoryMockTransactionParams{fn}

	// Record call args
	mmTransaction.TransactionMock.mutex.Lock()
	mmTransaction.TransactionMock.callArgs = append(mmTransaction.TransactionMock.callArgs, mm_params)
	mmTransaction.TransactionMock.mutex.Unlock()

	for _, e := range mmTransaction.TransactionMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmTransaction.TransactionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTransaction.TransactionMock.defaultExpectation.Counter, 1)
		mm_want := mmTransaction.TransactionMock.defaultExpectation.params
		mm_got := RepositoryMockTransactionParams{fn}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTransaction.t.Errorf("RepositoryMock.Transaction got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTransaction.TransactionMock.defaultExpectation.results
		if mm_results == nil {
			mmTransaction.t.Fatal("No results are set for the RepositoryMock.Transaction")
		}
		return (*mm_results).err
	}
	if mmTransaction.funcTransaction != nil {
		return mmTransaction.funcTransaction(fn)
	}
	mmTransaction.t.Fatalf("Unexpected call to RepositoryMock.Transaction. %v", fn)
	return
}

// TransactionAfterCounter returns a count of finished RepositoryMock.Transaction invocations
func (mmTransaction *RepositoryMock) TransactionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTransaction.afterTransactionCounter)
}

// TransactionBeforeCounter returns a count of RepositoryMock.Transaction invocations
func (mmTransaction *RepositoryMock) TransactionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTransaction.beforeTransactionCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.Transaction.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTransaction *mRepositoryMockTransaction) Calls() []*RepositoryMockTransactionParams {
	mmTransaction.mutex.RLock()

	argCopy := make([]*RepositoryMockTransactionParams, len(mmTransaction.callArgs))
	copy(argCopy, mmTransaction.callArgs)

	mmTransaction.mutex.RUnlock()

	return argCopy
}

// MinimockTransactionDone returns true if the count of the Transaction invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockTransactionDone() bool {
	for _, e := range m.TransactionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TransactionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTransactionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTransaction != nil && mm_atomic.LoadUint64(&m.afterTransactionCounter) < 1 {
		return false
	}
	return true
}

// MinimockTransactionInspect logs each unmet expectation
func (m *RepositoryMock) MinimockTransactionInspect() {
	for _, e := range m.TransactionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.Transaction with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TransactionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTransactionCounter) < 1 {
		if m.TransactionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.Transaction")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.Transaction with params: %#v", *m.TransactionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTransaction != nil && mm_atomic.LoadUint64(&m.afterTransactionCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.Transaction")
	}
}

type mRepositoryMockUpdateByID struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateByIDExpectation
	expectations       []*RepositoryMockUpdateByIDExpectation

	callArgs []*RepositoryMockUpdateByIDParams
	mutex    sync.RWMutex
}

// RepositoryMockUpdateByIDExpectation specifies expectation struct of the WalletRepository.UpdateByID
type RepositoryMockUpdateByIDExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockUpdateByIDParams
	results *RepositoryMockUpdateByIDResults
	Counter uint64
}

// RepositoryMockUpdateByIDParams contains parameters of the WalletRepository.UpdateByID
type RepositoryMockUpdateByIDParams struct {
	id      string
	name    *string
	balance *float64
	status  *bool
}

// RepositoryMockUpdateByIDResults contains results of the WalletRepository.UpdateByID
type RepositoryMockUpdateByIDResults struct {
	err error
}

// Expect sets up expected params for WalletRepository.UpdateByID
func (mmUpdateByID *mRepositoryMockUpdateByID) Expect(id string, name *string, balance *float64, status *bool) *mRepositoryMockUpdateByID {
	if mmUpdateByID.mock.funcUpdateByID != nil {
		mmUpdateByID.mock.t.Fatalf("RepositoryMock.UpdateByID mock is already set by Set")
	}

	if mmUpdateByID.defaultExpectation == nil {
		mmUpdateByID.defaultExpectation = &RepositoryMockUpdateByIDExpectation{}
	}

	mmUpdateByID.defaultExpectation.params = &RepositoryMockUpdateByIDParams{id, name, balance, status}
	for _, e := range mmUpdateByID.expectations {
		if minimock.Equal(e.params, mmUpdateByID.defaultExpectation.params) {
			mmUpdateByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateByID.defaultExpectation.params)
		}
	}

	return mmUpdateByID
}

// Inspect accepts an inspector function that has same arguments as the WalletRepository.UpdateByID
func (mmUpdateByID *mRepositoryMockUpdateByID) Inspect(f func(id string, name *string, balance *float64, status *bool)) *mRepositoryMockUpdateByID {
	if mmUpdateByID.mock.inspectFuncUpdateByID != nil {
		mmUpdateByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateByID")
	}

	mmUpdateByID.mock.inspectFuncUpdateByID = f

	return mmUpdateByID
}

// Return sets up results that will be returned by WalletRepository.UpdateByID
func (mmUpdateByID *mRepositoryMockUpdateByID) Return(err error) *RepositoryMock {
	if mmUpdateByID.mock.funcUpdateByID != nil {
		mmUpdateByID.mock.t.Fatalf("RepositoryMock.UpdateByID mock is already set by Set")
	}

	if mmUpdateByID.defaultExpectation == nil {
		mmUpdateByID.defaultExpectation = &RepositoryMockUpdateByIDExpectation{mock: mmUpdateByID.mock}
	}
	mmUpdateByID.defaultExpectation.results = &RepositoryMockUpdateByIDResults{err}
	return mmUpdateByID.mock
}

// Set uses given function f to mock the WalletRepository.UpdateByID method
func (mmUpdateByID *mRepositoryMockUpdateByID) Set(f func(id string, name *string, balance *float64, status *bool) (err error)) *RepositoryMock {
	if mmUpdateByID.defaultExpectation != nil {
		mmUpdateByID.mock.t.Fatalf("Default expectation is already set for the WalletRepository.UpdateByID method")
	}

	if len(mmUpdateByID.expectations) > 0 {
		mmUpdateByID.mock.t.Fatalf("Some expectations are already set for the WalletRepository.UpdateByID method")
	}

	mmUpdateByID.mock.funcUpdateByID = f
	return mmUpdateByID.mock
}

// When sets expectation for the WalletRepository.UpdateByID which will trigger the result defined by the following
// Then helper
func (mmUpdateByID *mRepositoryMockUpdateByID) When(id string, name *string, balance *float64, status *bool) *RepositoryMockUpdateByIDExpectation {
	if mmUpdateByID.mock.funcUpdateByID != nil {
		mmUpdateByID.mock.t.Fatalf("RepositoryMock.UpdateByID mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateByIDExpectation{
		mock:   mmUpdateByID.mock,
		params: &RepositoryMockUpdateByIDParams{id, name, balance, status},
	}
	mmUpdateByID.expectations = append(mmUpdateByID.expectations, expectation)
	return expectation
}

// Then sets up WalletRepository.UpdateByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateByIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateByIDResults{err}
	return e.mock
}

// UpdateByID implements models.WalletRepository
func (mmUpdateByID *RepositoryMock) UpdateByID(id string, name *string, balance *float64, status *bool) (err error) {
	mm_atomic.AddUint64(&mmUpdateByID.beforeUpdateByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateByID.afterUpdateByIDCounter, 1)

	if mmUpdateByID.inspectFuncUpdateByID != nil {
		mmUpdateByID.inspectFuncUpdateByID(id, name, balance, status)
	}

	mm_params := &RepositoryMockUpdateByIDParams{id, name, balance, status}

	// Record call args
	mmUpdateByID.UpdateByIDMock.mutex.Lock()
	mmUpdateByID.UpdateByIDMock.callArgs = append(mmUpdateByID.UpdateByIDMock.callArgs, mm_params)
	mmUpdateByID.UpdateByIDMock.mutex.Unlock()

	for _, e := range mmUpdateByID.UpdateByIDMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateByID.UpdateByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateByID.UpdateByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateByID.UpdateByIDMock.defaultExpectation.params
		mm_got := RepositoryMockUpdateByIDParams{id, name, balance, status}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateByID.t.Errorf("RepositoryMock.UpdateByID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateByID.UpdateByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateByID.t.Fatal("No results are set for the RepositoryMock.UpdateByID")
		}
		return (*mm_results).err
	}
	if mmUpdateByID.funcUpdateByID != nil {
		return mmUpdateByID.funcUpdateByID(id, name, balance, status)
	}
	mmUpdateByID.t.Fatalf("Unexpected call to RepositoryMock.UpdateByID. %v %v %v %v", id, name, balance, status)
	return
}

// UpdateByIDAfterCounter returns a count of finished RepositoryMock.UpdateByID invocations
func (mmUpdateByID *RepositoryMock) UpdateByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateByID.afterUpdateByIDCounter)
}

// UpdateByIDBeforeCounter returns a count of RepositoryMock.UpdateByID invocations
func (mmUpdateByID *RepositoryMock) UpdateByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateByID.beforeUpdateByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateByID *mRepositoryMockUpdateByID) Calls() []*RepositoryMockUpdateByIDParams {
	mmUpdateByID.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateByIDParams, len(mmUpdateByID.callArgs))
	copy(argCopy, mmUpdateByID.callArgs)

	mmUpdateByID.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateByIDDone returns true if the count of the UpdateByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateByIDDone() bool {
	for _, e := range m.UpdateByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateByIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateByID != nil && mm_atomic.LoadUint64(&m.afterUpdateByIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateByIDInspect() {
	for _, e := range m.UpdateByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateByID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateByIDCounter) < 1 {
		if m.UpdateByIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.UpdateByID")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateByID with params: %#v", *m.UpdateByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateByID != nil && mm_atomic.LoadUint64(&m.afterUpdateByIDCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.UpdateByID")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAllInspect()

		m.MinimockByIDInspect()

		m.MinimockCreateInspect()

		m.MinimockTransactionInspect()

		m.MinimockUpdateByIDInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAllDone() &&
		m.MinimockByIDDone() &&
		m.MinimockCreateDone() &&
		m.MinimockTransactionDone() &&
		m.MinimockUpdateByIDDone()
}
